# -*- coding: utf-8 -*-
"""IDS Presentation 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AW0kdJQnIU-_9rHfLGWMzaPMBrWucahd
"""

#Matplotlib

# Matplotlib is a popular 2D plotting library for Python.
# It provides a wide variety of customizable and high-quality
# plots for data visualization. Matplotlib is often used in
# combination with other libraries such as NumPy and pandas
# for data manipulation and analysis.

import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]


plt.plot(x, y)

plt.plot(x, y, label='Line')
plt.xlabel('X-axis Label')
plt.ylabel('Y-axis Label')
plt.title('Simple Plot')

plt.legend()

plt.show()

#Seaborn

# Seaborn is a statistical data visualization library built on top of Matplotlib.
# It provides a high-level interface for drawing attractive and informative statistical graphics.
# Seaborn comes with several built-in themes and color palettes to make it easy to create aesthetically pleasing visualizations.

import seaborn as sns

iris = sns.load_dataset('iris')

sns.scatterplot(x='sepal_length', y='sepal_width', data=iris)

sns.regplot(x='sepal_length', y='sepal_width', data=iris)
sns.boxplot(x='species', y='sepal_length', data=iris)
sns.set_theme(style="darkgrid")
sns.set_palette("deep")
g = sns.FacetGrid(iris, col='species')
g.map(sns.scatterplot, 'sepal_length', 'sepal_width')


sns.pairplot(iris, hue='species')

#Plotly

# Plotly is a Python graphing library that makes interactive,
# publication-quality graphs online. It supports a wide range of
# chart types and can be used for creating static or interactive
# visualizations. Plotly is particularly known for its ability to
# generate interactive plots that can be embedded in web applications
# or notebooks.

import plotly.graph_objects as go
from plotly.subplots import make_subplots


x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

fig = make_subplots(rows=1, cols=2, subplot_titles=['Plot 1', 'Plot 2'])

fig.add_trace(go.Scatter(x=x, y=y), row=1, col=1)

fig.add_trace(go.Bar(x=x, y=y), row=1, col=2)

# Show the subplot
fig.show()

#Bokeh

# Bokeh is a Python interactive visualization library that targets
# modern web browsers for presentation. It allows you to create
# interactive and real-time data visualizations in the browser
# using both Python and JavaScript. Bokeh can be used to build
# a variety of visualizations, including plots, charts, graphs,
# and dashboards.

from bokeh.plotting import figure, show
from bokeh.io import output_notebook
import numpy as np
from scipy.integrate import odeint

sigma = 10
rho = 28
beta = 8.0/3
theta = 3 * np.pi / 4

def lorenz(xyz, t):
    x, y, z = xyz
    x_dot = sigma * (y - x)
    y_dot = x * rho - x * z - y
    z_dot = x * y - beta* z
    return [x_dot, y_dot, z_dot]

initial = (-10, -7, 35)
t = np.arange(0, 100, 0.006)

solution = odeint(lorenz, initial, t)

x = solution[:, 0]
y = solution[:, 1]
z = solution[:, 2]
xprime = np.cos(theta) * x - np.sin(theta) * y

colors = ["#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5", "#08519C", "#08306B"]

p = figure(title="Lorenz attractor example", background_fill_color="#fafafa")

p.multi_line(np.array_split(xprime, 7), np.array_split(z, 7),
             line_color=colors, line_alpha=0.8, line_width=1.5)

output_notebook()
show(p)

#Altair

#Altair is a declarative statistical visualization library
# for Python that is based on the Vega and Vega-Lite visualization
# grammars. It provides a simple and concise syntax for creating
# a wide range of interactive visualizations. Altair is designed
# to work seamlessly with the Pandas library, making it easy to
# visualize data directly from DataFrames.

import altair as alt
from vega_datasets import data

# Since the data is more than 5,000 rows we'll import it from a URL
source = data.zipcodes.url

alt.Chart(source).transform_calculate(
    "leading digit", alt.expr.substring(alt.datum.zip_code, 0, 1)
).mark_circle(size=3).encode(
    longitude='longitude:Q',
    latitude='latitude:Q',
    color='leading digit:N',
    tooltip='zip_code:N'
).project(
    type='albersUsa'
).properties(
    width=650,
    height=400
)

#Geopandas

# GeoPandas is an open-source Python library that provides high-performance,
# easy-to-use data structures and data analysis tools for working with
# geographic/spatial data. It extends the capabilities of the popular Pandas
# library to allow spatial operations on geometric types. GeoPandas makes
# it easier to work with geospatial data by providing a GeoDataFrame object
# that combines the functionality of Pandas DataFrames with geometry support provided by the Shapely library.

#NetworkX


# NetworkX is a Python library for the creation, analysis,
# and visualization of complex networks (or graphs). It
# provides tools for the study of the structure and dynamics
# of networks, and it is widely used in various domains,
# including social network analysis, biology, transportation, and more.

import networkx as nx
import matplotlib.pyplot as plt


G = nx.Graph()

G.add_nodes_from([1, 2, 3])

G.add_edges_from([(1, 2), (2, 3), (3, 1)])

nx.draw(G, with_labels=True, font_weight='bold')
plt.show()

#HoloViews

#HoloViews is a Python library that simplifies the process
# of data visualization by providing a high-level interface
# for constructing complex visualizations easily. It's built
# on top of the PyViz ecosystem and is designed to work seamlessly
# with Pandas and other data manipulation libraries.
# HoloViews allows users to declare what they want to visualize,
# and it automatically generates the corresponding plots.
# The library supports a wide range of visualizations, including
# scatter plots, line plots, heatmaps, and more.


# Example showing how bifurcation diagram for the logistic map
# relates to the Mandelbrot set according to a linear transformation.


from itertools import islice
import numpy as np
import holoviews as hv
from holoviews import opts
hv.extension('bokeh')

# Area of the complex plane
bounds = (-2,-1.4,0.8,1.4)
# Growth rates used in the logistic map
growth_rates = np.linspace(0.9, 4, 1000)
# Bifurcation points
bifurcations = [1, 3, 3.4494, 3.5440, 3.5644, 3.7381, 3.7510, 3.8284, 3.8481]

def mandelbrot_generator(h,w, maxit, bounds=bounds):
    "Generator that yields the mandlebrot set."
    (l,b,r,t) = bounds
    y,x = np.ogrid[b:t : h*1j, l:r:w*1j]
    c = x+y*1j
    z = c
    divtime = maxit + np.zeros(z.shape, dtype=int)
    for i in range(maxit):
        z  = z**2 + c
        diverge = z*np.conj(z) > 2**2
        div_now = diverge & (divtime==maxit)
        divtime[div_now] = i
        z[diverge] = 2
        yield divtime

def mandelbrot(h,w, n, maxit):
    "Returns the mandelbrot set computed to maxit"
    iterable =  mandelbrot_generator(h,w, maxit)
    return next(islice(iterable, n, None))

def mapping(r):
    "Linear mapping applied to the logistic bifurcation diagram"
    return (r /2.0) * ( 1 - (r/2.0))

def logistic_map(gens=20, init=0.5, growth=0.5):
    population = [init]
    for gen in range(gens-1):
        current = population[gen]
        population.append(current * growth * (1 - current))
    return population

bifurcation_diagram = hv.Points([(mapping(rate), pop) for rate in growth_rates for
             (gen, pop) in enumerate(logistic_map(gens=110, growth=rate))
             if gen>=100])  # Discard the first 100 generations to view attractors more easily

vlines = hv.Overlay([hv.Curve([(mapping(pos),0), ((mapping(pos),1.4))]) for pos in bifurcations])
overlay = (hv.Image(mandelbrot(800,800, 45, 46).copy(), bounds=(-2, -1.4, 0.8, 1.4))
           * bifurcation_diagram * hv.HLine(0) * vlines)

hv.output(size=150)
overlay.opts(
    opts.HLine(color='k', line_dash='dashed'),
    opts.Image(cmap='Reds', logz=True, xaxis=None, yaxis=None),
    opts.Points(size=0.5, color='g'),
    opts.Curve(color='teal', line_width=1))